//1、天书版6.0重构版，支持S5全局反代，全局反代外部环境变量名【SOCKS5GLOBAL】，true和false
//2、支持反代开关，私钥开关，全局分段开关，订阅隐藏开关功能，去除UUID限制，clash私钥防止被薅请求数
//3、又再重新修改了接口关闭逻辑，降低请求数（请求数大幅度降低）和错误率（worker引发异常为0，至少我测试的是）
//4、修改传输方式，增加分片传输，可提升传输稳定性
//5、支持SOCKS5，支持外部环境变量，变量名【SOCKS5】，只支持一个SOCKS5，并且SOCKS5和原始反代只能二选一，建议有稳定SOCKS5的人使用，白嫖玩家不建议使用，为了方便切换增加了一个外部变量【SOCKS5OPEN】，true打开和false关闭
//6、不用在意那些奇怪的变量名，根据后面注释的备注去改，大概也就前50行看一下备注就行，clash配置在底部，懂的可以根据自身需求修改
//7、纯手搓配置，去除任何API外链，直接改好了部署就行，这样安全性史无前例
//8、通用订阅不支持私钥功能，使用通用订阅需关闭私钥功能再订阅节点，CF不支持自身1.1.1.1的DNS解析，如果无法连通可以检查客户端DNS设置
//9、由于本人仅使用openclash和clash meta，其他平台软件均未测试，请自行测试研究，要是不能用就算了，不负责改进，继续概不负责^_^
//10、由于本人纯菜，很多代码解释都是根据自己的理解瞎编的，专业的无视就好，单纯为了帮助小白理解代码大致原理^_^

import { connect } from 'cloudflare:sockets';

let 哎呀呀这是我的ID啊 = "tianshu"; //实际上这是你的订阅路径，支持任意大小写字母和数字，[域名/ID]进入订阅页面
let 哎呀呀这是我的VL密钥 = "7688f3cb-96d7-481e-992b-4d106c7b6d71"; //这是真实的UUID，通用订阅会进行验证，建议修改为自己的规范化UUID

let 私钥开关 = false //是否启用私钥功能，true启用，false不启用，因为私钥功能只支持clash，如果打算使用通用订阅则需关闭私钥功能
let 咦这是我的私钥哎 = ""; //这是你的私钥，提高隐秘性安全性，就算别人扫到你的域名也无法链接，再也不怕别人薅请求数了^_^

let 隐藏订阅 = false //选择是否隐藏订阅页面，false不隐藏，true隐藏，当然隐藏后自己也无法订阅，因为配置固定，适合自己订阅后就隐藏，防止被爬订阅，并且可以到下方添加嘲讽语^_^
let 嘲讽语 = "哎呀你找到了我，但是我就是不给你看，气不气，嘿嘿嘿" //隐藏订阅后，真实的订阅页面就会显示这段话，想写啥写啥

let 我的优选 = 'www.visa.com#visa国际
www.visa.com.tt#visa特立尼达&多巴哥
www.visa.com.ar#visa阿根廷
www.visaeurope.at#visa奥地利
www.visa.com.az#visa阿塞拜疆
www.visa.be#visa比利时
www.visa.com.bz#visa伯利兹
www.visa.com.bo#visa玻利维亚
www.visa.com.br#visa巴西
www.visa.com.kh#visa柬埔寨
www.visa.com.co#visa哥伦比亚
www.visa.com.hr#visa克罗地亚
www.visa.com.cy#visa塞浦路斯
www.visa.com.do#visa多明尼加共和国
www.visa.com.ec#visa厄瓜多尔
cf.090227.xyz#三网自适应分流官方优选
ct.090227.xyz#电信官方优选
cmcc.090227.xyz#移动官方' //CF的节点，填域名或IP，好的优选一个就够了，由于CFcdn常规13端口开放，可以生成全端口节点，如果留空则会使用你自定义域的小黄云代理
let 我的优选IPV6 = '' //CF的IPV6节点，填域名或IP，好的优选一个就够了，由于CFcdn常规13端口开放，可以生成全端口节点，如果留空则会使用你自定义域的小黄云代理

let 特殊优选 = 'ProxyIP.SG.fxxk.dedyn.io' //非CF的节点，填域名或IP，结合你的反代一起使用的话，这个节点可以完全的固定落地地区，例如同时都使用美国的
let 特殊优选的端口 = '443' //非CF的节点端口
let 非CF节点是否打开tls = 'true' //非CF的节点TLS开关，true，false，通用订阅此功能无效，默认使用tls
let 特殊优选的host = '' //方便给建了全局S5反代的同学，不用的留空就行

let 启用反代功能 = true //选择是否启用反代功能，false，true，现在你可以自由的选择是否启用反代功能了
let 反代IP = 'ts.hpc.tw' //反代IP或域名，反代IP端口一般情况下不用填写，如果你非要用非标反代的话，可以填'ts.hpc.tw:443'这样

let 启用SOCKS5反代 = false //如果启用此功能，原始反代将失效
let 启用SOCKS5全局反代 = false //选择是否启用SOCKS5全局反代，启用后所有访问都是S5的落地【无论你客户端选什么节点】，访问路径是客户端--CF--SOCKS5，当然启用此功能后延迟=CF+SOCKS5，带宽取决于SOCKS5的带宽，不再享受CF高速和随时满带宽的待遇
let 我的SOCKS5账号 = '' //格式'账号:密码@地址:端口'

let 我的节点名字 = '天书6.0重构版' //自己的节点名字

let 伪装网页 = '' //填入伪装网页，格式'www.youku.com'，如果不填，脚本本身有个内置的简单代理页面，建议用小站伪装或者直接内置，比较靠谱

let 启用全局分段 = true //选择是否使用全局分段功能，试验功能，分段传输可以降低worker压力，提升传输稳定性，同时也加快响应速度，但是由于SOCKS5跟全局分段功能可能有冲突，如果使用SOCKS5无法反代的话可以尝试关闭分段功能
let 分段大小 = 4*1024; //分段大小，建议不要随意修改，这是测试的比较适合的数值，建议的数值为1-4K
let 限速等级 = 0; //限速等级，主动限制速度以达到稳定性需求【例如直播，勉强可以720P】，数值越大越慢，0为不限速，自行根据分段大小动态调整【个人调试的数值为分段大小 = 4*1024，限速等级 = 5】
//////////////////////////////////////////////////////////////////////////网页入口////////////////////////////////////////////////////////////////////////
export default {
  async fetch(访问请求, env) {
      const 读取我的请求标头 = 访问请求.headers.get('Upgrade');
      const url = new URL(访问请求.url);
      if (!读取我的请求标头 || 读取我的请求标头 !== 'websocket') {
          switch (url.pathname) {
              case `/${哎呀呀这是我的ID啊}`: {
                  const 订阅页面 = 给我订阅页面(哎呀呀这是我的ID啊, 访问请求.headers.get('Host'));
                  return new Response(`${订阅页面}`, {
                      status: 200,
                      headers: {
                          "Content-Type": "text/plain;charset=utf-8",
                      }
                  });
              }
              case `/${哎呀呀这是我的ID啊}/${转码}${转码2}`: {
                  if (隐藏订阅) {
                  return new Response (`${嘲讽语}`, {
                  status: 200,
                  headers: {
                      "Content-Type": "text/plain;charset=utf-8",
                      }
                  });
                  } else {
                  const 通用配置文件 = 给我通用配置文件(访问请求.headers.get('Host'));
                  return new Response(`${通用配置文件}`, {
                      status: 200,
                      headers: {
                          "Content-Type": "text/plain;charset=utf-8",
                      }
                  });
                }
              }
              case `/${哎呀呀这是我的ID啊}/${小猫}${咪}`: {
                  if (隐藏订阅) {
                  return new Response (`${嘲讽语}`, {
                  status: 200,
                  headers: {
                      "Content-Type": "text/plain;charset=utf-8",
                      }
                  });
                  } else {
                  const 小猫咪配置文件 = 给我小猫咪配置文件(访问请求.headers.get('Host'));
                  return new Response(`${小猫咪配置文件}`, {
                      status: 200,
                      headers: {
                          "Content-Type": "text/plain;charset=utf-8",
                      }
                  });
                }
              }
              default:
              if (伪装网页) {
                  url.hostname = 伪装网页;
                  url.protocol = 'https:';
                  访问请求 = new Request(url, 访问请求);
                  return fetch(访问请求);
              } else {
                  访问请求 = new Request(url, 访问请求);
                  return 代理页面(访问请求);
              }
          }
      } else if (读取我的请求标头 === 'websocket'){
          我的优选 = env.IPV4 || 我的优选;
          我的优选IPV6 = env.IPV6 || 我的优选IPV6;
          反代IP = env.PROXYIP || 反代IP;
          我的SOCKS5账号 = env.SOCKS5 || 我的SOCKS5账号;
          启用SOCKS5反代 = (env.SOCKS5OPEN === 'true') ? true : (env.SOCKS5OPEN === 'false' ? false : 启用SOCKS5反代);
          启用SOCKS5全局反代 = (env.SOCKS5GLOBAL === 'true') ? true : (env.SOCKS5GLOBAL === 'false' ? false : 启用SOCKS5全局反代);
          if (私钥开关) {
          const 验证我的私钥 = 访问请求.headers.get('my-key')
          if (验证我的私钥 === 咦这是我的私钥哎) {
          return await 升级WS请求(访问请求);
          }
          }
          if (!私钥开关) {
          return await 升级WS请求(访问请求);
          }
      }
  }
};
////////////////////////////////////////////////////////////////////////内置代理页面//////////////////////////////////////////////////////////////////////
async function 代理页面(request) {
  const url = new URL(request.url);
  if (url.pathname === '/' || url.pathname === '/proxy/') {
    return createLandingPage();
  }
  let actualUrlStr = url.pathname.replace("/proxy/", "") + url.search + url.hash;
  if (!actualUrlStr.startsWith('http://') && !actualUrlStr.startsWith('https://')) {
    actualUrlStr = 'https://' + actualUrlStr;
  }
  try {
    const actualUrl = new URL(actualUrlStr);
    const modifiedRequest = new Request(actualUrl, {
      headers: request.headers,
      method: request.method,
      body: (request.method === 'POST' || request.method === 'PUT') ? request.body : undefined,
      redirect: 'follow'
    });
    const response = await fetch(modifiedRequest);
    if (!response.ok) {
      throw new Error(`Fetch request failed with status: ${response.status}`);
    }
    const clonedResponseBody = await response.clone().text();
    const modifiedResponse = new Response(clonedResponseBody, response);
    modifiedResponse.headers.set('Access-Control-Allow-Origin', '*');
    modifiedResponse.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
    modifiedResponse.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    return modifiedResponse;
  } catch (error) {
    return new Response(`Error: ${error.message}`, { status: 500 });
  }
  
}
function createLandingPage() {
  const html = `
  <!DOCTYPE html>
  <html lang="en">
  <head>
  <style>
  body {
    background-color: #fbfbfb;
    font-family: Arial, sans-serif;
  }
  h1 {
    text-align: center;
    color: #444;
  }
  .container {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }
  form {
    background-color: white;
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23);
    padding: 2rem;
    border-radius: 8px;
  }
  input {
    display: block;
    width: 100%;
    font-size: 18px;
    padding: 15px;
    border: solid 1px #ccc;
    border-radius: 4px;
    margin: 1rem 0;
  }
  button {
    padding: 15px;
    background-color: #0288d1;
    color: white;
    font-size: 18px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    width: 100%;
  }
  button:hover {
    background-color: #039BE5;
  }
</style>
    <meta charset="UTF-8">
    <title>逍遥君的代理服务器</title>
  </head>
  <body>
    <h1>输入您想访问的网址，本网页主要方便拉库用，并不能科学</h1>
    <form id="proxy-form">
      <input type="text" id="url" name="url" placeholder="https://示例.com" required />
      <button type="submit">访问</button>
    </form>
    <script>
      const form = document.getElementById('proxy-form');
      form.addEventListener('submit', event => {
        event.preventDefault();
        const input = document.getElementById('url');
        const actualUrl = input.value;
        const proxyUrl = '/proxy/' + actualUrl;
        location.href = proxyUrl;
      });
    </script>
  </body>
  </html>
  `;
  return new Response(html, {
    headers: { 'Content-Type': 'text/html' }
  });
}
////////////////////////////////////////////////////////////////////////脚本主要架构//////////////////////////////////////////////////////////////////////
//第一步，读取和构建基础访问结构
async function 升级WS请求(访问请求) {
  const 创建WS接口 = new WebSocketPair();
  const [客户端, WS接口] = Object.values(创建WS接口);
  WS接口.accept();
  const 读取我的加密访问内容数据头 = 访问请求.headers.get('sec-websocket-protocol');
  const 解密数据 = 使用64位加解密(读取我的加密访问内容数据头); //解密目标访问数据，传递给TCP握手进程
  const { TCP接口, 写入初始数据 } = await 解析VL标头(解密数据); //解析VL数据并进行TCP握手
  建立传输管道(WS接口, TCP接口, 写入初始数据);
  return new Response(null, { status: 101, webSocket: 客户端 });
}
function 使用64位加解密(还原混淆字符) {
  还原混淆字符 = 还原混淆字符.replace(/-/g, '+').replace(/_/g, '/');
  const 解密数据 = atob(还原混淆字符);
  const 解密_你_个_丁咚_咙_咚呛 = Uint8Array.from(解密数据, (c) => c.charCodeAt(0));
  return 解密_你_个_丁咚_咙_咚呛.buffer;
}
//第二步，解读VL协议数据，创建TCP握手
async function 解析VL标头(VL数据) {
  const 获取数据定位 = new Uint8Array(VL数据.slice(17, 18))[0];
  const 提取端口索引 = 18 + 获取数据定位 + 1;
  const 建立端口缓存 = VL数据.slice(提取端口索引, 提取端口索引 + 2);
  const 访问端口 = new DataView(建立端口缓存).getUint16(0);
  const 提取地址索引 = 提取端口索引 + 2;
  const 建立地址缓存 = new Uint8Array(VL数据.slice(提取地址索引, 提取地址索引 + 1));
  const 识别地址类型 = 建立地址缓存[0];
  let 地址长度 = 0;
  let 访问地址 = '';
  let 地址信息索引 = 提取地址索引 + 1;
  switch (识别地址类型) {
    case 1:
      地址长度 = 4;
      访问地址 = new Uint8Array( VL数据.slice(地址信息索引, 地址信息索引 + 地址长度) ).join('.');
      break;
    case 2:
      地址长度 = new Uint8Array( VL数据.slice(地址信息索引, 地址信息索引 + 1) )[0];
      地址信息索引 += 1;
      访问地址 = new TextDecoder().decode( VL数据.slice(地址信息索引, 地址信息索引 + 地址长度) );
      break;
    case 3:
      地址长度 = 16;
      const dataView = new DataView( VL数据.slice(地址信息索引, 地址信息索引 + 地址长度) );
      const ipv6 = [];
      for (let i = 0; i < 8; i++) { ipv6.push(dataView.getUint16(i * 2).toString(16)); }
      访问地址 = ipv6.join(':');
      break;
  }
  let TCP接口
  let [反代IP地址, 反代IP端口] = 反代IP.split(':');
  const 写入初始数据 = VL数据.slice(地址信息索引 + 地址长度);
  if (启用反代功能 && 启用SOCKS5反代 && 启用SOCKS5全局反代) {
    TCP接口 = await 创建SOCKS5接口(识别地址类型, 访问地址, 访问端口);
    return { TCP接口, 写入初始数据 };
  } else {
    try {
    TCP接口 = connect({ hostname: 访问地址, port: 访问端口 });
    await TCP接口.opened;
    } catch {
      if (启用反代功能) {
        if (启用SOCKS5反代) {
          TCP接口 = await 创建SOCKS5接口(识别地址类型, 访问地址, 访问端口);
        } else {
          TCP接口 = connect({ hostname: 反代IP地址, port: 反代IP端口 || 访问端口 });
        }
      }
    } finally {
      return { TCP接口, 写入初始数据 };
    }
  }
}
//第三步，创建客户端WS-CF-目标的传输通道并监听状态
async function 建立传输管道(WS接口, TCP接口, 写入初始数据) {
  await WS接口.send(new Uint8Array([0, 0]).buffer);
  const 数据流 = new ReadableStream({ //监听WS接口数据并发送给数据流
    async start(控制器) {
      if (写入初始数据) { 控制器.enqueue(写入初始数据) };
      WS接口.addEventListener('message', (event) => { 控制器.enqueue(event.data) }); //监听客户端WS接口消息，推送给数据流
      WS接口.addEventListener('close', () => { 控制器.close(); return; }); //监听客户端WS接口关闭信息，结束流传输
      WS接口.addEventListener('error', () => { 控制器.close(); TCP接口.close(); WS接口.close(); return; }); //监听客户端WS接口异常信息，结束流传输
    }
  });
  数据流.pipeTo(new WritableStream({ //将客户端接收到的WS数据发往TCP接口
    async write(VL数据) {
      const 传输数据 = TCP接口.writable.getWriter();
      try {
        if (启用全局分段) {
          await 发往TCP目标的分块传输(传输数据, VL数据);
        } else {
          await 传输数据.write(VL数据);
        }
      } catch {
      } finally {
        传输数据.releaseLock();
      }
    }
  }));
  TCP接口.readable.pipeTo(new WritableStream({ //将TCP接口返回的数据通过WS接口发送回客户端
    async write(VL数据) {
      try {
        if (启用全局分段) {
          await WS回传的分块传输(WS接口, VL数据);
        } else {
          await WS接口.send(VL数据);
        }
      } catch {
      }
    },
  }));
  检查并关闭接口(WS接口, TCP接口);
}
async function 检查并关闭接口(WS接口, TCP接口) {
  while (true) {
    if (WS接口.bufferedAmount === 0) {
      TCP接口.close();
      WS接口.close(1000);
      break;
    }
    await new Promise(resolve => setTimeout(resolve, 50));
  }
}
async function 发往TCP目标的分块传输(传输数据, VL数据, offset = 0) {
  while (offset < VL数据.byteLength) {
    const 分段数据块 = VL数据.slice(offset, offset + 分段大小);
    await 传输数据.write(分段数据块);
    offset += 分段大小;
    await new Promise(resolve => setTimeout(resolve, 0));
  }
}
async function WS回传的分块传输(WS接口, VL数据, offset = 0) {
  while (offset < VL数据.byteLength) {
    const 分段数据块 = VL数据.slice(offset, offset + 分段大小);
    await WS接口.send(分段数据块);
    offset += 分段大小;
    await new Promise(resolve => setTimeout(resolve, 限速等级));
  }
}
//////////////////////////////////////////////////////////////////////////SOCKS5部分//////////////////////////////////////////////////////////////////////
async function 创建SOCKS5接口(识别地址类型, 访问地址, 访问端口) {
  const { username, password, hostname, port } = await 获取SOCKS5账号(我的SOCKS5账号);
  const SOCKS5接口 = connect({ hostname, port });
  try {
    await SOCKS5接口.opened;
  } catch {
    return new Response('SOCKS5未连通', { status: 400 });
  }
  const writer = SOCKS5接口.writable.getWriter();
  const reader = SOCKS5接口.readable.getReader();
  const encoder = new TextEncoder();
  const socksGreeting = new Uint8Array([5, 2, 0, 2]); //构建认证信息,支持无认证和用户名/密码认证
  await writer.write(socksGreeting);
  let res = (await reader.read()).value;
  if (res[1] === 0x02) { //检查是否需要用户名/密码认证
    if (!username || !password) {
      return 关闭接口并退出();
    }
    const authRequest = new Uint8Array([ 1, username.length, ...encoder.encode(username), password.length, ...encoder.encode(password) ]); // 发送用户名/密码认证请求
    await writer.write(authRequest);
    res = (await reader.read()).value;
    if (res[0] !== 0x01 || res[1] !== 0x00) {
      return 关闭接口并退出(); // 认证失败
    }
  }
  let 转换访问地址;
  switch (识别地址类型) {
    case 1: // IPv4
      转换访问地址 = new Uint8Array( [1, ...访问地址.split('.').map(Number)] );
      break;
    case 2: // 域名
      转换访问地址 = new Uint8Array( [3, 访问地址.length, ...encoder.encode(访问地址)] );
      break;
    case 3: // IPv6
      转换访问地址 = new Uint8Array( [4, ...访问地址.split(':').flatMap(x => [parseInt(x.slice(0, 2), 16), parseInt(x.slice(2), 16)])] );
      break;
    default:
      return 关闭接口并退出();
  }
  const socksRequest = new Uint8Array([ 5, 1, 0, ...转换访问地址, 访问端口 >> 8, 访问端口 & 0xff ]); //发送转换后的访问地址/端口
  await writer.write(socksRequest);
  res = (await reader.read()).value;
  if (res[0] !== 0x05 || res[1] !== 0x00) {
    return 关闭接口并退出(); // 连接失败
  }
  writer.releaseLock();
  reader.releaseLock();
  return SOCKS5接口;
  function 关闭接口并退出() {
    writer.releaseLock();
    reader.releaseLock();
    SOCKS5接口.close();
    return new Response('SOCKS5握手失败', { status: 400 });
  }
}
async function 获取SOCKS5账号(SOCKS5) {
  const [latter, former] = SOCKS5.split("@").reverse();
  let username, password, hostname, port;
  if (former) {
    const formers = former.split(":");
    username = formers[0];
    password = formers[1];
  }
  const latters = latter.split(":");
  port = Number(latters.pop());
  hostname = latters.join(":");
  return { username, password, hostname, port };
}
//////////////////////////////////////////////////////////////////////////订阅页面////////////////////////////////////////////////////////////////////////
let 转码 = 'vl', 转码2 = 'ess', 符号 = '://', 小猫 = 'cla', 咪 = 'sh', 我的私钥;
if (私钥开关) {
  我的私钥 = `my-key: ${咦这是我的私钥哎}`
} else {
  我的私钥 = ""
}
function 给我订阅页面(哎呀呀这是我的ID啊, hostName) {
return `
1、本worker的私钥功能只支持${小猫}${咪}，仅open${小猫}${咪}和${小猫}${咪} meta测试过，其他${小猫}${咪}类软件自行测试
2、若使用通用订阅请关闭私钥功能
3、其他需求自行研究
通用的：https${符号}${hostName}/${哎呀呀这是我的ID啊}/${转码}${转码2}
猫咪的：https${符号}${hostName}/${哎呀呀这是我的ID啊}/${小猫}${咪}
`;
}
function 给我通用配置文件(hostName) {
if (!我的优选){
  我的优选 = hostName
}
if (!我的优选IPV6){
  我的优选IPV6 = hostName
}
if (!特殊优选的host) {
  特殊优选的host = hostName
}
const 特殊长链接Links = btoa(`
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选}:80?encryption=none&security=none&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选}:8080?encryption=none&security=none&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选}:8880?encryption=none&security=none&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选}:2052?encryption=none&security=none&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选}:2082?encryption=none&security=none&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选}:2086?encryption=none&security=none&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选}:2095?encryption=none&security=none&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选}:443?encryption=none&security=tls&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选}:8443?encryption=none&security=tls&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选}:2053?encryption=none&security=tls&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选}:2083?encryption=none&security=tls&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选}:2087?encryption=none&security=tls&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选}:2096?encryption=none&security=tls&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选IPV6}:80?encryption=none&security=none&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选IPV6}:8080?encryption=none&security=none&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选IPV6}:8880?encryption=none&security=none&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选IPV6}:2052?encryption=none&security=none&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选IPV6}:2082?encryption=none&security=none&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选IPV6}:2086?encryption=none&security=none&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选IPV6}:2095?encryption=none&security=none&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选IPV6}:443?encryption=none&security=tls&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选IPV6}:8443?encryption=none&security=tls&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选IPV6}:2053?encryption=none&security=tls&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选IPV6}:2083?encryption=none&security=tls&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选IPV6}:2087?encryption=none&security=tls&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${我的优选IPV6}:2096?encryption=none&security=tls&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${特殊优选}:${特殊优选的端口}?encryption=none&security=tls&type=ws&host=${特殊优选的host}&path=%2F%3Fed%3D2560
${转码}${转码2}${符号}${哎呀呀这是我的VL密钥}@${hostName}:443?encryption=none&security=tls&type=ws&host=${hostName}&path=%2F%3Fed%3D2560
`);
if (私钥开关) {
  return `请先关闭私钥功能`
}else {
  return `${特殊长链接Links}`
}
}
function 给我小猫咪配置文件(hostName) {
if (!我的优选){
  我的优选 = hostName
}
if (!我的优选IPV6){
  我的优选IPV6 = hostName
}
if (!特殊优选的host) {
  特殊优选的host = hostName
}
return `
dns:
  nameserver:
    - 119.29.29.29
    - 223.5.5.5
  fallback:
    - 8.8.8.8
    - 2001:4860:4860::8888
    - tls://dns.google
proxies:
- name: ${我的节点名字}-notls-80
  type: ${转码}${转码2}
  server: ${我的优选}
  port: 80
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: false
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-notls-8080
  type: ${转码}${转码2}
  server: ${我的优选}
  port: 8080
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: false
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-notls-8880
  type: ${转码}${转码2}
  server: ${我的优选}
  port: 8880
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: false
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-notls-2052
  type: ${转码}${转码2}
  server: ${我的优选}
  port: 2052
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: false
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-notls-2082
  type: ${转码}${转码2}
  server: ${我的优选}
  port: 2082
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: false
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-notls-2086
  type: ${转码}${转码2}
  server: ${我的优选}
  port: 2086
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: false
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-notls-2095
  type: ${转码}${转码2}
  server: ${我的优选}
  port: 2095
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: false
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-tls-443
  type: ${转码}${转码2}
  server: ${我的优选}
  port: 443
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: true
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-tls-8443
  type: ${转码}${转码2}
  server: ${我的优选}
  port: 8443
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: true
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-tls-2053
  type: ${转码}${转码2}
  server: ${我的优选}
  port: 2053
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: true
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-tls-2083
  type: ${转码}${转码2}
  server: ${我的优选}
  port: 2083
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: true
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-tls-2087
  type: ${转码}${转码2}
  server: ${我的优选}
  port: 2087
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: true
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-tls-2096
  type: ${转码}${转码2}
  server: ${我的优选}
  port: 2096
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: true
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-IPV6-notls-80
  type: ${转码}${转码2}
  server: ${我的优选IPV6}
  port: 80
  ip-version: ipv6 # ip-version设置，可以自定义强制走ipv4或ipv6，ipv6-prefer则是双栈优先走ipv6
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: false
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-IPV6-notls-8080
  type: ${转码}${转码2}
  server: ${我的优选IPV6}
  port: 8080
  ip-version: ipv6 # ip-version设置，可以自定义强制走ipv4或ipv6，ipv6-prefer则是双栈优先走ipv6
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: false
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-IPV6-notls-8880
  type: ${转码}${转码2}
  server: ${我的优选IPV6}
  port: 8880
  ip-version: ipv6 # ip-version设置，可以自定义强制走ipv4或ipv6，ipv6-prefer则是双栈优先走ipv6
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: false
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-IPV6-notls-2052
  type: ${转码}${转码2}
  server: ${我的优选IPV6}
  port: 2052
  ip-version: ipv6 # ip-version设置，可以自定义强制走ipv4或ipv6，ipv6-prefer则是双栈优先走ipv6
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: false
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-IPV6-notls-2082
  type: ${转码}${转码2}
  server: ${我的优选IPV6}
  port: 2082
  ip-version: ipv6 # ip-version设置，可以自定义强制走ipv4或ipv6，ipv6-prefer则是双栈优先走ipv6
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: false
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-IPV6-notls-2086
  type: ${转码}${转码2}
  server: ${我的优选IPV6}
  port: 2086
  ip-version: ipv6 # ip-version设置，可以自定义强制走ipv4或ipv6，ipv6-prefer则是双栈优先走ipv6
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: false
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-IPV6-notls-2095
  type: ${转码}${转码2}
  server: ${我的优选IPV6}
  port: 2095
  ip-version: ipv6 # ip-version设置，可以自定义强制走ipv4或ipv6，ipv6-prefer则是双栈优先走ipv6
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: false
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-IPV6-tls-443
  type: ${转码}${转码2}
  server: ${我的优选IPV6}
  port: 443
  ip-version: ipv6 # ip-version设置，可以自定义强制走ipv4或ipv6，ipv6-prefer则是双栈优先走ipv6
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: true
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-IPV6-tls-8443
  type: ${转码}${转码2}
  server: ${我的优选IPV6}
  port: 8443
  ip-version: ipv6 # ip-version设置，可以自定义强制走ipv4或ipv6，ipv6-prefer则是双栈优先走ipv6
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: true
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-IPV6-tls-2053
  type: ${转码}${转码2}
  server: ${我的优选IPV6}
  port: 2053
  ip-version: ipv6 # ip-version设置，可以自定义强制走ipv4或ipv6，ipv6-prefer则是双栈优先走ipv6
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: true
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-IPV6-tls-2083
  type: ${转码}${转码2}
  server: ${我的优选IPV6}
  port: 2083
  ip-version: ipv6 # ip-version设置，可以自定义强制走ipv4或ipv6，ipv6-prefer则是双栈优先走ipv6
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: true
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-IPV6-tls-2087
  type: ${转码}${转码2}
  server: ${我的优选IPV6}
  port: 2087
  ip-version: ipv6 # ip-version设置，可以自定义强制走ipv4或ipv6，ipv6-prefer则是双栈优先走ipv6
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: true
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-IPV6-tls-2096
  type: ${转码}${转码2}
  server: ${我的优选IPV6}
  port: 2096
  ip-version: ipv6 # ip-version设置，可以自定义强制走ipv4或ipv6，ipv6-prefer则是双栈优先走ipv6
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: true
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-非CF节点
  type: ${转码}${转码2}
  server: ${特殊优选}
  port: ${特殊优选的端口}
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: ${非CF节点是否打开tls}
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${特殊优选的host}
      ${我的私钥}
- name: ${我的节点名字}-备用IPV4节点
  type: ${转码}${转码2}
  server: ${hostName}
  port: 443
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: true
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
- name: ${我的节点名字}-备用IPV6节点
  type: ${转码}${转码2}
  server: ${hostName}
  port: 443
  ip-version: ipv6-prefer  # ip-version设置，可以自定义强制走ipv4或ipv6，ipv6-prefer则是双栈优先走ipv6
  uuid: ${哎呀呀这是我的VL密钥}
  udp: false
  tls: true
  network: ws
  ws-opts:
    path: "/?ed=2560"
    headers:
      Host: ${hostName}
      ${我的私钥}
proxy-groups:
- name: 🚀 节点选择
  type: select
  proxies:
    - notls负载均衡
    - tls负载均衡
    - IPV6-notls负载均衡
    - IPV6-tls负载均衡
    - 自动选择
    - ${我的节点名字}-notls-80
    - ${我的节点名字}-notls-8080
    - ${我的节点名字}-notls-8880
    - ${我的节点名字}-notls-2052
    - ${我的节点名字}-notls-2082
    - ${我的节点名字}-notls-2086
    - ${我的节点名字}-notls-2095
    - ${我的节点名字}-tls-443
    - ${我的节点名字}-tls-8443
    - ${我的节点名字}-tls-2053
    - ${我的节点名字}-tls-2083
    - ${我的节点名字}-tls-2087
    - ${我的节点名字}-tls-2096
    - ${我的节点名字}-IPV6-notls-80
    - ${我的节点名字}-IPV6-notls-8080
    - ${我的节点名字}-IPV6-notls-8880
    - ${我的节点名字}-IPV6-notls-2052
    - ${我的节点名字}-IPV6-notls-2082
    - ${我的节点名字}-IPV6-notls-2086
    - ${我的节点名字}-IPV6-notls-2095
    - ${我的节点名字}-IPV6-tls-443
    - ${我的节点名字}-IPV6-tls-8443
    - ${我的节点名字}-IPV6-tls-2053
    - ${我的节点名字}-IPV6-tls-2083
    - ${我的节点名字}-IPV6-tls-2087
    - ${我的节点名字}-IPV6-tls-2096
    - ${我的节点名字}-非CF节点
    - ${我的节点名字}-备用IPV4节点
    - ${我的节点名字}-备用IPV6节点
- name: 自动选择
  type: url-test
  url: http://www.gstatic.com/generate_204
  interval: 300
  tolerance: 50
  proxies:
    - ${我的节点名字}-notls-80
    - ${我的节点名字}-notls-8080
    - ${我的节点名字}-notls-8880
    - ${我的节点名字}-notls-2052
    - ${我的节点名字}-notls-2082
    - ${我的节点名字}-notls-2086
    - ${我的节点名字}-notls-2095
    - ${我的节点名字}-tls-443
    - ${我的节点名字}-tls-8443
    - ${我的节点名字}-tls-2053
    - ${我的节点名字}-tls-2083
    - ${我的节点名字}-tls-2087
    - ${我的节点名字}-tls-2096
    - ${我的节点名字}-IPV6-notls-80
    - ${我的节点名字}-IPV6-notls-8080
    - ${我的节点名字}-IPV6-notls-8880
    - ${我的节点名字}-IPV6-notls-2052
    - ${我的节点名字}-IPV6-notls-2082
    - ${我的节点名字}-IPV6-notls-2086
    - ${我的节点名字}-IPV6-notls-2095
    - ${我的节点名字}-IPV6-tls-443
    - ${我的节点名字}-IPV6-tls-8443
    - ${我的节点名字}-IPV6-tls-2053
    - ${我的节点名字}-IPV6-tls-2083
    - ${我的节点名字}-IPV6-tls-2087
    - ${我的节点名字}-IPV6-tls-2096
    - ${我的节点名字}-非CF节点
    - ${我的节点名字}-备用IPV4节点
    - ${我的节点名字}-备用IPV6节点
- name: notls负载均衡
  type: load-balance
  url: http://www.gstatic.com/generate_204
  interval: 300
  proxies:
    - ${我的节点名字}-notls-80
    - ${我的节点名字}-notls-8080
    - ${我的节点名字}-notls-8880
    - ${我的节点名字}-notls-2052
    - ${我的节点名字}-notls-2082
    - ${我的节点名字}-notls-2086
    - ${我的节点名字}-notls-2095
- name: tls负载均衡
  type: load-balance
  url: http://www.gstatic.com/generate_204
  interval: 300
  proxies:
    - ${我的节点名字}-tls-443
    - ${我的节点名字}-tls-8443
    - ${我的节点名字}-tls-2053
    - ${我的节点名字}-tls-2083
    - ${我的节点名字}-tls-2087
    - ${我的节点名字}-tls-2096
- name: IPV6-notls负载均衡
  type: load-balance
  url: http://www.gstatic.com/generate_204
  interval: 300
  proxies:
    - ${我的节点名字}-IPV6-notls-80
    - ${我的节点名字}-IPV6-notls-8080
    - ${我的节点名字}-IPV6-notls-8880
    - ${我的节点名字}-IPV6-notls-2052
    - ${我的节点名字}-IPV6-notls-2082
    - ${我的节点名字}-IPV6-notls-2086
    - ${我的节点名字}-IPV6-notls-2095
- name: IPV6-tls负载均衡
  type: load-balance
  url: http://www.gstatic.com/generate_204
  interval: 300
  proxies:
    - ${我的节点名字}-IPV6-tls-443
    - ${我的节点名字}-IPV6-tls-8443
    - ${我的节点名字}-IPV6-tls-2053
    - ${我的节点名字}-IPV6-tls-2083
    - ${我的节点名字}-IPV6-tls-2087
    - ${我的节点名字}-IPV6-tls-2096
- name: 非CF节点
  type: select
  proxies:
    - ${我的节点名字}-非CF节点
- name: 漏网之鱼
  type: select
  proxies:
    - DIRECT
    - 🚀 节点选择
    - 非CF节点
rules:
# 策略规则，部分规则需打开${小猫}${咪} mate的使用geoip dat版数据库，比如TG规则就需要，或者自定义geoip的规则订阅
# 这是geoip的规则订阅链接，https://cdn.jsdelivr.net/gh/Loyalsoldier/geoip@release/Country.mmdb
# GPT规则
- DOMAIN-KEYWORD,openai,🚀 节点选择
- DOMAIN-SUFFIX,AI.com,🚀 节点选择
- DOMAIN-SUFFIX,cdn.auth0.com,🚀 节点选择
- DOMAIN-SUFFIX,openaiapi-site.azureedge.net,🚀 节点选择
- DOMAIN-SUFFIX,opendns.com,🚀 节点选择
- DOMAIN-SUFFIX,bing.com,🚀 节点选择
- DOMAIN-SUFFIX,civitai.com,🚀 节点选择
- DOMAIN,bard.google.com,🚀 节点选择
- DOMAIN,ai.google.dev,🚀 节点选择
- DOMAIN,gemini.google.com,🚀 节点选择
- DOMAIN-SUFFIX,googleapis.com,🚀 节点选择
- DOMAIN-SUFFIX,sentry.io,🚀 节点选择
- DOMAIN-SUFFIX,intercom.io,🚀 节点选择
- DOMAIN-SUFFIX,featuregates.org,🚀 节点选择
- DOMAIN-SUFFIX,statsigapi.net,🚀 节点选择
- DOMAIN-SUFFIX,claude.ai,🚀 节点选择
- DOMAIN-SUFFIX,Anthropic.com,🚀 节点选择
- DOMAIN-SUFFIX,opera-api.com,🚀 节点选择
- DOMAIN-SUFFIX,aistudio.google.com,🚀 节点选择
- DOMAIN-SUFFIX,auth0.com,🚀 节点选择
- DOMAIN-SUFFIX,challenges.cloudflare.com,🚀 节点选择
- DOMAIN-SUFFIX,chatgpt.com,🚀 节点选择
- DOMAIN-SUFFIX,client-api.arkoselabs.com,🚀 节点选择
- DOMAIN-SUFFIX,events.statsigapi.net,🚀 节点选择
- DOMAIN-SUFFIX,identrust.com,🚀 节点选择
- DOMAIN-SUFFIX,intercomcdn.com,🚀 节点选择
- DOMAIN-SUFFIX,oaistatic.com,🚀 节点选择
- DOMAIN-SUFFIX,oaiusercontent.com,🚀 节点选择
- DOMAIN-SUFFIX,openai.com,🚀 节点选择
- DOMAIN-SUFFIX,stripe.com,🚀 节点选择
# GPT规则
# - GEOSITE,category-ads,REJECT #简单广告过滤规则，要增加规则数可使用category-ads-all
- GEOSITE,cn,DIRECT #国内域名直连规则
- GEOIP,CN,DIRECT,no-resolve #国内IP直连规则
- GEOSITE,cloudflare,DIRECT #CF域名直连规则
- GEOIP,CLOUDFLARE,DIRECT,no-resolve #CFIP直连规则
- GEOSITE,gfw,🚀 节点选择 #GFW域名规则
- GEOSITE,google,🚀 节点选择 #GOOGLE域名规则
- GEOIP,GOOGLE,🚀 节点选择,no-resolve #GOOGLE IP规则
- GEOSITE,netflix,🚀 节点选择 #奈飞域名规则
- GEOIP,NETFLIX,🚀 节点选择,no-resolve #奈飞IP规则
- GEOSITE,telegram,🚀 节点选择 #TG域名规则
- GEOIP,TELEGRAM,🚀 节点选择,no-resolve #TG IP规则
- MATCH,漏网之鱼
`
}
